<!DOCTYPE html>
<html lang="en">
	<head>
		<title>image composing - mosaic</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
			  .thumb {
    height: 40px;
    width: 40px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }
		</style>
	</head>
	<body>

		<input type="file" id="files" name="files[]" multiple />
		<output id="list"></output>

		<script src="http://threejs.org/build/three.min.js"></script> 
		<script src="http://underscorejs.org/underscore-min.js"></script>

		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/DotScreenShader.js"></script>
		<script src="js/shaders/RGBShiftShader.js"></script>
		<script src="js/shaders/MapShader.js"></script>
		<script src="js/shaders/ReduceShader.js"></script>
		<script src="js/shaders/MosaicComparerShader.js"></script>
		<script src="js/shaders/MosaicImageComposerShader.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/MosaicPass.js"></script>
		<script src="js/postprocessing/TexturePass.js"></script>
		<script src="js/postprocessing/SavePass.js"></script>

		<script src="js/FileIO.js" ></script>


		<script>

			var camera, scene, renderer, imageComparer, mosaicMap, renderTarget, mosaicImageComposer;
			var object, light;
			var previousSingleImageMap ;	
			var width = 400.0; var height = 400.0;
			var mosaicWidth = 20.0, mosaicHeight = 20.0;
			var bestResultMap = new Uint8Array(width * width * 4);
			var bestImageAtPositionMap = {};
			var currentMosaicImageIdentifier = '';

			init();
			animate();

			function init() {			
				bestResultMap = _.map(bestResultMap, function(e) { return 255;});

				InitializeThreejs();

				window.addEventListener( 'resize', onWindowResize, false );

			}


			function InitializeThreejs(){
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( width, height );
				//renderer.setViewport(0,0, width, height);
				document.body.appendChild( renderer.domElement );

				var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

				renderTargetOriginalImage = new THREE.WebGLRenderTarget( width, height, parameters );

				//camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
				camera = new THREE.OrthographicCamera( width / -2, width / 2, height / 2, height / -2, 1, 100 );
				camera.position.z = 2;

				var mosaicImage = THREE.ImageUtils.loadTexture('img/2013-08-19 15.30.53.png');
				currentMosaicImageIdentifier = 'img/2013-08-19 15.30.53.png';
				var resultImage = THREE.ImageUtils.loadTexture('img/2013-08-19 15.30.55.png');

				createMosaicTemplateWith(mosaicImage);	

				createImageComparer(resultImage);				

				// var latestSingleImageMap= imageComparer.renderTarget2;		
				// if (previousSingleImageMap == undefined){
				// 	previousSingleImageMap = latestSingleImageMap;
				// }


				// createMosaicMap(previousSingleImageMap, latestSingleImageMap);
				// mosaicMap.render();

				// previousSingleImageMap = mosaicMap.renderTarget2;

				/*insertMosaicImageIntoResultImage(previousSingleImageMap, THREE.ImageUtils.loadTexture('img/white.png'), 0.01);
				mosaicImageComposer.render();*/	

			}

			function createMosaicTemplateWith(mosaicImage){
				scene = new THREE.Scene();

				var mat = new THREE.MeshBasicMaterial({ color: 0x0000ff });
				var radius = 5; 
				var segments = 10; 
				var circleGeometry = new THREE.CircleGeometry( radius, segments );
				var circle = new THREE.Mesh( circleGeometry, mat ); 
				scene.add( circle );

				circle = new THREE.Mesh(circleGeometry, mat);
				circle.position.set(-20.0,0,0);
				scene.add(circle);

				object = new THREE.Object3D();

				var geometry = new THREE.PlaneBufferGeometry( mosaicWidth, mosaicHeight );
				var material =  new THREE.MeshBasicMaterial({ map: mosaicImage});		

				var maxMosaicItemCountX = width / mosaicWidth;
				var maxMosaicItemCountY = height / mosaicHeight;
				for ( i = -Math.floor(maxMosaicItemCountX / 2.0); i < Math.floor(maxMosaicItemCountX / 2.0); i += 1 ) {
			      for ( j = -Math.floor(maxMosaicItemCountY / 2.0); j < Math.floor(maxMosaicItemCountY / 2.0); j += 1 ) {
			        var instance = new THREE.Mesh( geometry, material );
			        instance.position.set( i*mosaicWidth+(mosaicWidth / 2.0), j*mosaicHeight+(mosaicHeight / 2.0), 0 );
			        object.add( instance );
			      }
			    }

			    scene.add( object );

				// scene.add( new THREE.AmbientLight( 0x222222 ) );

				// light = new THREE.DirectionalLight( 0xffffff );
				// light.position.set( 1, 1, 10 );
				// scene.add( light );
			}

						// width and height auf 40x40 reduzieren

			function createImageComparer(resultImage){
				imageComparer = new THREE.EffectComposer( renderer, renderTarget);
				imageComparer.addPass( new THREE.RenderPass( scene, camera ) );
				//imageComparer.addPass( new THREE.ShaderPass(THREE.CopyShader));
				imageComparer.addPass( new THREE.MosaicPass( THREE.MapShader, 0.01, resultImage, width, height, 1.0, 1.0));
				//imageComparer.addPass( new THREE.MosaicPass( THREE.ReduceShader, 0.01, null, width, height, 3.0, 3.0));
				//imageComparer.addPass( new THREE.MosaicPass( THREE.ReduceShader, 0.01, null, width, height, 9.0, 9.0));
				var screenPass = new THREE.ShaderPass(THREE.CopyShader);			
				screenPass.renderToScreen = true;
				imageComparer.addPass( screenPass );
			}

			function createMosaicMap (previousSingleImageMap, latestSingleImageMap){
					var mosaicMapScene = new THREE.Scene();
				geometry = new THREE.PlaneBufferGeometry( mosaicWidth, mosaicHeight,0 );
				material =  new THREE.MeshBasicMaterial({ map: previousSingleImageMap});	
				 var instance = new THREE.Mesh( geometry, material );
				 mosaicMapScene.add(instance);
				mosaicMapScene.add(light);
				mosaicMap = new THREE.EffectComposer( renderer );
				mosaicMap.addPass( new THREE.RenderPass( mosaicMapScene, camera ) );				
				mosaicMap.addPass( new THREE.MosaicPass(THREE.MosaicComparerShader, null, latestSingleImageMap, width, height))
				var screenPass = new THREE.ShaderPass(THREE.CopyShader);			
				screenPass.renderToScreen = true;
				mosaicMap.addPass(screenPass);
			}

			function insertMosaicImageIntoResultImage(mosaicMap, mosaicImage, mosaicImageId){
				var mosaicImageScene = new THREE.Scene();
				var geometry = new THREE.PlaneGeometry( mosaicWidth, mosaicHeight,0 );
				var material =  new THREE.MeshBasicMaterial({ map: mosaicMap});	
				var instance = new THREE.Mesh( geometry, material );
				mosaicImageScene.add(instance);
				mosaicImageScene.add(light);
				mosaicImageComposer = new THREE.EffectComposer( renderer );
				mosaicImageComposer.addPass( new THREE.RenderPass( mosaicImageScene, camera ) );
				mosaicImageComposer.addPass( new THREE.MosaicPass(THREE.MosaicImageComposerShader, mosaicImageId, mosaicImage, width, height))
				var copyToScreenShader = new THREE.ShaderPass(THREE.CopyShader);
				copyToScreenShader.renderToScreen = true;				
				mosaicImageComposer.addPass( copyToScreenShader);	
			}

			function getResult(context){
				var arr2, arr1 = new Uint8Array(width * width * 4);

  				context.readPixels(0, 0, width, width, context.RGBA, context.UNSIGNED_BYTE, arr1);

  				return arr1;
			}



			function onWindowResize() {

				//camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {
				requestAnimationFrame( animate );

				//renderer.render(scene, camera);	

				//renderer.setViewport(0,0, width, height);

				imageComparer.render();	

				var currentResult = getResult(renderer.context);
				for (var i = 0; i < currentResult.length; i+=3) {
					var currentMeanIntensityValue = 0.3333333333 * (currentResult[i] + currentResult[i+1] + currentResult[i+2]);
					var bestMeanIntensityValue = 0.3333333333 * (bestResultMap[i] + bestResultMap[i+1] + bestResultMap[i+2]);
					if (currentMeanIntensityValue < bestMeanIntensityValue) {
						bestImageAtPositionMap[i] = currentMosaicImageIdentifier;
						bestResultMap[i] = currentResult[i];
						bestResultMap[i+1] = currentResult[i+1];
						bestResultMap[i+2] = currentResult[i+2];
					};
				};
			}

		</script>

		 <script type="text/javascript">
		  document.getElementById('files').addEventListener('change', handleFileSelect, false);
		 </script>
	</body>
</html>